%title css 模块化 

== 问题 ==
* 独立性, 多人开发保证不相互干扰, 避免命名冲突
* 复用性, 减少重复劳动


== 要求 ==
* 命名清晰
* 保证 class 解析高效


== 已有方法 ==

=== 1. 模块名+子选择器 === 
.itembox {
}
.itembox .hd{
}
.itembox .bd{
}
.itembox .ft{
}

==== 说明 ====
* 有点 oocss 思想
* 缺点
  * 子选择器在全局有定义时冲突
  * 选择器容易过长(E F F2 F3 F4), 效率低
  * 嵌套有顺序要求, class 声明顺序
* 优点
  * 可扩展性好



=== 2. 模块名加长 ===
.itembox {
}
.itembox-hd{
}
.itembox-bd{
}
.itembox-ft{
}


==== 说明 ====
* 优点
  * 子选择器无命名冲突问题
  * 选择器不会过长, 效率没问题
  * 可以任意嵌套
* 缺点
  * 选择器名字长, 增加文件体积
  * 模块扩展麻烦, 没有子选择器(每个子元素都需要有多个class)



=== oocss ===
* 减少重复定义: 基础样式+扩展覆盖
* make each object predictable and location indenpendent(保证复用)
* use hacks sparingly and don't let them change your specificity
* avoid styling ids, not reusable
* avoid !important, except for leaf node
* styling classes rather than elements
* give rules the same strengh, use cascade order to overwrite previous rules(保证优先级可以覆盖)
* http://www.slideshare.net/stubbornella/css-bloat
* http://www.slideshare.net/stubbornella/object-oriented-css



=== css class 名称语义化 ===
* http://css-tricks.com/semantic-class-names/



=== 参考 ===
* http://renaissancenerd.net/post/7435876863/writing-modular-and-reusable-css
* css 渲染速度: https://developers.google.com/speed/docs/best-practices/rendering
* https://developer.mozilla.org/en-US/docs/CSS/Writing_Efficient_CSS?redirectlocale=en-US&redirectslug=Writing_Efficient_CSS
